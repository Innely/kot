<!DOCTYPE HTML>
<html>
<head>
<title><meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</title>
</head>
<body background="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQ72SBB1eW6IzOaO3L8MFccrgW6v7VXJn0o3-4tf3llyveafPyv">
 <MARQUEE style="WIDTH: 200px" direction=left><h5>Блог компании Яндекс.</h5></MARQUEE>
 <MARQUEE style="WIDTH: 900px" direction=left><img src="https://life-hack.com.ua/wp-content/uploads/2017/05/email-yandex.png"></MARQUEE>
<H2><b>ЯНДЕКС.ПОЧТА: КАК МЫ ИЗМЕРЯЕМ СКОРОСТЬ ЗАГРУЗКИ И УЛУЧШАЕМ ЕЁ</b> </h2>
<div class="block2"><p>Если ваш сайт медленно грузится, вы рискуете тем, что люди не оценят ни то,
какой он красивый, ни то, какой он удобный. Никому не понравится, когда все
тормозит.<br> Мы регулярно добавляем в Яндекс.Почту новую функциональность,
иногда — исправляем ошибки, а это значит, у нас постоянно появляются новый код
и новая логика.<br>Всё это напрямую влияет на скорость работы интерфейса.</p></div>
<img src="http://habrastorage.org/files/7df/dd2/0ce/7dfdd20ceaea4a5eb09b298b60199470.png" align="right">
 <dt><HR><MARQUEE style="WIDTH: 200px" behavior=alternate><p><H3>Что мы измеряем</H3></p></MARQUEE></HR></dt>
<p><dt>Этапы первой загрузки:</dt></p>
<dd><ul><li>подготовка;</li>
<li>загрузка статики (HTTP-запрос и парсинг);</li>
<li>исполнение модулей;</li>
<li>инициализация базовых объектов;</li>
<li>отрисовка.</li></ul></dd>
<p><dt>Этапы отрисовки любой страницы:</dt></p>
<dd><ul><li>подготовка к запросу на сервер;</li>
<li>запрос данных с сервера;</li>
<li>шаблонизация;</li>
<li>обновление DOM.</li></ul></dd>
<blockquote style="border:3px #4682B4 solid; padding: 5px; margin:20px 20px 20px 20px;"><b>
<IMAGE ALIGN="LEFT" VALIGN="MIDDLE" SRC="http://businesslike.ru/uploads/monthly_01_2014/post-2-0-66942200-1390124767.png" ALT="комментарий"> <IMAGE ALIGN="RIGHT" VALIGN="MIDDLE" SRC="http://businesslike.ru/uploads/monthly_01_2014/post-2-0-66942200-1390124767.png" ALT="комментарий"> 
— «Ок, теперь у нас есть метрики, мы можем отправить их на сервер» - говорим мы<br>
— «Что же дальше?» - вопрошаете вы<br>
— «А давай построим график!» - отвечаем мы<br>
— «А что будем считать?» - уточняете вы</b></blockquote>
<dd>Как вы знаете, медиана – это серединное, а не среднее значение в выборке.Если у нас имеются числа 1, 2, 2, 3, 8, 10, 20, то медиана – 3, а среднее – 6,5.В общем случае медиана отлично показывает, сколько грузится средний пользователь.<br>
В случае ускорения или замедления медиана, конечно, изменится. Но она не может рассказать, сколько пользователей ускорилось, а сколько замедлилось.<br>
APDEX – метрика, которая сразу говорит: хорошо или плохо. Метрика
работает очень просто. Мы выбираем временной интервал [0; t], такой, что если время показа страницы попало в него, то пользователь счастлив. Берем еще один интервал, (t; 4t] (в четыре раза больше первого), и считаем, что если страница показана за это время, то пользователь в целом удовлетворен скоростью работы,но уже не настолько счастлив. И применяем формулу:<br>

<b>(кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во всех).</b><br>
Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,
хорошо или плохо работает почта.
<p><H3>Как мы измеряем</H3></p>
<p>Сейчас модуль обновления сам логирует все свои стадии, и можно легко понять
причину замедления: медленнее стал отвечать сервер либо слишком долго
выполняется JavaScript. Выглядит это примерно так:
</p>
<p><big>this.timings['look-ma-im-start'] = Date.now();<br>
this.timings['look-ma-finish'] = Date.now();</big></p>
<p>C помощью Date.now() мы получаем текущее время. Все тайминги собираются и при отправке рассчитываются. На этапах разница между “end” и “start” не считается,а все вычисления производятся в конце:</p>
<p><big>var totalTime = this.timings['look-ma-finish'] - this.timings['look-ma-im-start'];</big></p>
<p>И на сервер прилетают подобные записи:</p>
<p><u>serverResponse=50&domUpdate=60</u></p>
<p><H3>Как мы ускоряем</H3></p>
<p>Чтобы снизить время загрузки почты при выходе новых версий,
мы уже делаем следующее:</p>
<ul><li>включаем gzip;</li>
<li>выставляем заголовки кэширования;</li>
<li>фризим CSS, JS, шаблоны и картинки;</li>
<li>используем CDN;</li></ul>
<blockquote style="background-color: #B0C4DE; border:3px #4682B4 solid; padding: 10px; margin:0px 0px 0px 0px;">Мы подумали: «А что если хранить где-то старую версию файлов, а при выходе новой передавать только diff между ней и той, которая сохранена у пользователя?»
В браузере же останется просто наложить патч на клиенте.<br>
<p>На самое деле эта идея не нова. Уже существуют стандарты для HTTP — например,RFC 3229 «Delta encoding in HTTP» и «Google SDHC», — но по разным причинам они не получили должного распространения в браузерах и на серверах.</p><br>
Мы же решили сделать свой аналог на JS. Чтобы реализовать этот метод обновления,начали искать реализации diff на JS. На популярных хостингах кода нашлибиблиотеки:<br>
- VCDiff<br>
- google-diff-patch-match</p></blockquote>
<p>Для окончательного выбора библиотеки нам нужно сравнить:</p>

<table border="1">
   <caption></caption>
   <tr>
    <th>Библиотека </th>
    <th>IE 9</th>
    <th>Opera 12</th>
    
   </tr>
   <tr bgcolor="#FFFFFF" onmouseover="style.backgroundColor='#FFFF99'" onmouseout="style.backgroundColor='#FFFFFF'"><td>vcdiff</td><td>8</td><td>5
   <tr bgcolor="#FFFFFF" onmouseover="style.backgroundColor='#FFFF99'" onmouseout="style.backgroundColor='#FFFFFF'"><td>google diff</td><td>1363</td><td>76</td></table>
   <p>После того как мы определились с библиотекой для диффа, нужно определиться с тем,где и как хранить статику на клиенте.</p>
   <p>Формат файла с патчами для проекта выглядит так:</p>
   <p>[
    {
        "k": "jane.css",
        "p": [patch],
        "s": 4554
    },
    {
        "k": "jane.css",
        "p": [patch],
        "s": 4554
    }
]</p>
<p>То есть это обычный массив из объектов. Каждый объект — отдельный ресурс. У
каждого объекта есть три свойства. k — названия ключа в localStorage для этого
ресурса. p — патч для ресурса, который сгенерировал vcdiff. s — чексумма для
ресурса актуальной версии, чтобы потом можно было проверить правильность
наложения патча на клиенте. Чексумма вычисляется по алгоритму Флетчера.</p>
<p>Алгоритм Бройдена — Флетчера — Гольдфарба — Шанно (BFGS)
— итерационный метод численной оптимизации, предназначенный для
нахождения локального максимума/минимума нелинейного функционала
без ограничений.</p>
<p>Почему именно алгоритм Флетчера, а не другие популярные алгоритмы вроде:
CRC16/32 - алгоритм нахождения контрольной суммы, предназначенный для проверки целостности данных md5 - 128-битный алгоритм хеширования. Предназначен для создания «отпечатков» или дайджестов сообщения произвольной длины и последующей проверки их подлинности.<br>
          
Потому что он быстрый, компактный и легок в реализации.</p>
<p><h2>Итог</h2></p>
<p><b>Фактически мы экономим 80-90% трафика. Размер загружаемой статитки в байтах:</b></p>
<table border="1">
   <caption></caption>
   <tr>
    <th>Релиз </th>
    <th>С патчем</th>
    <th>Без патча</th>
    
   </tr>
   <tr bgcolor="#FFFFFF" onmouseover="style.backgroundColor='#FFFF99'" onmouseout="style.backgroundColor='#FFFFFF'"><td>7.7.20</td><td>397</td><td>174549</td>
   <tr bgcolor="#FFFFFF" onmouseover="style.backgroundColor='#FFFF99'" onmouseout="style.backgroundColor='#FFFFFF'"><td>7.7.21</td><td>383</td><td>53995</td>
   <tr bgcolor="#FFFFFF" onmouseover="style.backgroundColor='#FFFF99'" onmouseout="style.backgroundColor='#FFFFFF'"><td>7.7.22</td><td>483</td><td>3995</td></table>
<ul class="main-menu">
            <li><a href="#company">Автор: @doochik С++ разработик</a></li>
            <li><a href="#services">Электронная почта: (doochik@yandex-team.ru)</a>
                <ul class="sub-menu">
                    <li><a href="#1">Компания: Яндекс</a></li>
                </ul>
     <blockquote style="background-color: #FFE4B5; border:3px #BC8F8F solid; padding: 10px; margin:0px 0px 0px 0px;">Комментарии (3):<br>

- Mogaika (mogaika@yandex-team.ru) 30 ноября 2014 в 17:05<br>

  А можете привести сравнение, на сколько быстрее грузится lite версия?<br>

- JIguse (mrawesome@yandex.ru) 29 ноября 2014 в 21:30<br>

  Спасибо за статью, познавательно. Здорово, что Яндекс делится некоторыми
  подробностями о внутренней работе сервисов.<br>

- Brister (brist89@yandex-team.ru) 24 ноября 2014 в 13:13<br>

  (кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во всех).
  Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,
  хорошо или плохо работает почта.
  наверное все-таки от 0.5 до 1<br>

- alexeimois (test@yandex.ru) 22 ноября 2014 в 17:35<br>

  <p>Мы измеряем скорость загрузки с помощью Яндекс.Метрики:
  help.yandex.ru/metrika/reports/monitoring_timing.xml</p></blockquote>
</body>
</html>
